// Command generate-data reads browsers.css-data.json from
// microsoft/vscode-custom-data and produces Go source files for
// the internal/css/data package.
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"sort"
	"strings"
)

const header = "// Code generated by cmd/generate-data; DO NOT EDIT.\n\npackage data\n"

// JSON structures matching browsers.css-data.json.
type cssData struct {
	Properties     []cssProperty    `json:"properties"`
	AtDirectives   []cssAtDirective `json:"atDirectives"`
	PseudoClasses  []cssPseudoClass `json:"pseudoClasses"`
	PseudoElements []cssPseudoElem  `json:"pseudoElements"`
}

type cssProperty struct {
	Name        string          `json:"name"`
	Description json.RawMessage `json:"description"`
	References  []cssReference  `json:"references"`
	Values      []cssValue      `json:"values"`
}

type cssAtDirective struct {
	Name        string          `json:"name"`
	Description json.RawMessage `json:"description"`
	References  []cssReference  `json:"references"`
}

type cssPseudoClass struct {
	Name        string          `json:"name"`
	Description json.RawMessage `json:"description"`
	References  []cssReference  `json:"references"`
}

type cssPseudoElem struct {
	Name        string          `json:"name"`
	Description json.RawMessage `json:"description"`
	References  []cssReference  `json:"references"`
}

type cssReference struct {
	Name string `json:"name"`
	URL  string `json:"url"`
}

type cssValue struct {
	Name string `json:"name"`
}

// descriptionObj handles the case where description is
// {kind, value} instead of a plain string.
type descriptionObj struct {
	Kind  string `json:"kind"`
	Value string `json:"value"`
}

func parseDescription(raw json.RawMessage) string {
	if len(raw) == 0 {
		return ""
	}
	// Try string first.
	var s string
	if err := json.Unmarshal(raw, &s); err == nil {
		return s
	}
	// Try object.
	var obj descriptionObj
	if err := json.Unmarshal(raw, &obj); err == nil {
		return obj.Value
	}
	return ""
}

func mdnURL(refs []cssReference) string {
	for _, r := range refs {
		if strings.Contains(r.URL, "developer.mozilla.org") {
			return r.URL
		}
	}
	return ""
}

func isVendorPrefixed(name string) bool {
	// Strip leading @, :, or :: then check for -.
	s := strings.TrimLeft(name, "@:")
	return strings.HasPrefix(s, "-")
}

func goStr(s string) string {
	return fmt.Sprintf("%q", s)
}

func main() {
	// Locate project root relative to this source file.
	_, thisFile, _, _ := runtime.Caller(0)
	root := filepath.Join(filepath.Dir(thisFile), "..", "..")

	dataFile := filepath.Join(root, "third_party", "vscode-custom-data",
		"web-data", "data", "browsers.css-data.json")
	outDir := filepath.Join(root, "internal", "css", "data")

	//nolint:gosec // generator tool, path not user-controlled
	raw, err := os.ReadFile(dataFile)
	if err != nil {
		log.Fatalf("reading data file: %v", err)
	}

	var data cssData
	if err := json.Unmarshal(raw, &data); err != nil {
		log.Fatalf("parsing JSON: %v", err)
	}

	generateProperties(outDir, data.Properties)
	generateAtRules(outDir, data.AtDirectives)
	generatePseudo(outDir, data.PseudoClasses, data.PseudoElements)

	fmt.Printf("Generated files in %s\n", outDir)
}

func generateProperties(outDir string, props []cssProperty) {
	// Filter and sort.
	var filtered []cssProperty
	for _, p := range props {
		if !isVendorPrefixed(p.Name) {
			filtered = append(filtered, p)
		}
	}
	sort.Slice(filtered, func(i, j int) bool {
		return filtered[i].Name < filtered[j].Name
	})

	var b strings.Builder
	b.WriteString(header)
	b.WriteString("\n//nolint:dupword\nvar Properties = []Property{\n")

	for _, p := range filtered {
		desc := parseDescription(p.Description)
		mdn := mdnURL(p.References)

		b.WriteString("\t{\n")
		b.WriteString("\t\tName:        " + goStr(p.Name) + ",\n")
		if desc != "" {
			b.WriteString("\t\tDescription: " + goStr(desc) + ",\n")
		}
		if mdn != "" {
			b.WriteString("\t\tMDN:         " + goStr(mdn) + ",\n")
		}

		// Collect value keywords (skip vendor-prefixed).
		var vals []string
		for _, v := range p.Values {
			if !strings.HasPrefix(v.Name, "-") {
				vals = append(vals, v.Name)
			}
		}
		if len(vals) > 0 {
			b.WriteString("\t\tValues: []string{")
			if len(vals) <= 4 {
				for i, v := range vals {
					if i > 0 {
						b.WriteString(", ")
					}
					b.WriteString(goStr(v))
				}
				b.WriteString("},\n")
			} else {
				b.WriteString("\n")
				for _, v := range vals {
					b.WriteString("\t\t\t" + goStr(v) + ",\n")
				}
				b.WriteString("\t\t},\n")
			}
		}

		b.WriteString("\t},\n")
	}

	b.WriteString("}\n\n")
	b.WriteString("var propertyMap = buildPropertyMap()\n\n")
	b.WriteString("func buildPropertyMap() map[string]Property {\n")
	b.WriteString("\tm := make(map[string]Property, len(Properties))\n")
	b.WriteString("\tfor _, p := range Properties {\n")
	b.WriteString("\t\tm[p.Name] = p\n")
	b.WriteString("\t}\n")
	b.WriteString("\treturn m\n")
	b.WriteString("}\n")

	writeFile(filepath.Join(outDir, "properties_gen.go"), b.String())
	fmt.Printf("  properties_gen.go: %d properties\n", len(filtered))
}

func generateAtRules(outDir string, directives []cssAtDirective) {
	var filtered []cssAtDirective
	for _, a := range directives {
		if !isVendorPrefixed(a.Name) {
			filtered = append(filtered, a)
		}
	}
	sort.Slice(filtered, func(i, j int) bool {
		return filtered[i].Name < filtered[j].Name
	})

	var b strings.Builder
	b.WriteString(header)
	b.WriteString("\nvar AtRules = []AtRuleDef{\n")

	for _, a := range filtered {
		desc := parseDescription(a.Description)
		// Strip leading @ for the name.
		name := strings.TrimPrefix(a.Name, "@")

		b.WriteString("\t{")
		b.WriteString("Name: " + goStr(name))
		if desc != "" {
			b.WriteString(", Description: " + goStr(desc))
		}
		b.WriteString("},\n")
	}

	b.WriteString("}\n\n")
	b.WriteString("var atRuleMap = buildAtRuleMap()\n\n")
	b.WriteString("func buildAtRuleMap() map[string]AtRuleDef {\n")
	b.WriteString("\tm := make(map[string]AtRuleDef, len(AtRules))\n")
	b.WriteString("\tfor _, a := range AtRules {\n")
	b.WriteString("\t\tm[a.Name] = a\n")
	b.WriteString("\t}\n")
	b.WriteString("\treturn m\n")
	b.WriteString("}\n")

	writeFile(filepath.Join(outDir, "at_rules_gen.go"), b.String())
	fmt.Printf("  at_rules_gen.go: %d at-rules\n", len(filtered))
}

func generatePseudo(outDir string, classes []cssPseudoClass, elements []cssPseudoElem) {
	// Filter and sort pseudo-classes.
	var filteredClasses []cssPseudoClass
	for _, p := range classes {
		if !isVendorPrefixed(p.Name) {
			filteredClasses = append(filteredClasses, p)
		}
	}
	sort.Slice(filteredClasses, func(i, j int) bool {
		return filteredClasses[i].Name < filteredClasses[j].Name
	})

	// Filter and sort pseudo-elements.
	var filteredElements []cssPseudoElem
	for _, p := range elements {
		if !isVendorPrefixed(p.Name) {
			filteredElements = append(filteredElements, p)
		}
	}
	sort.Slice(filteredElements, func(i, j int) bool {
		return filteredElements[i].Name < filteredElements[j].Name
	})

	var b strings.Builder
	b.WriteString(header)

	// Pseudo-classes.
	b.WriteString(
		"\n// PseudoClasses contains definitions for CSS pseudo-classes.\nvar PseudoClasses = []PseudoClass{\n",
	)
	for _, p := range filteredClasses {
		desc := parseDescription(p.Description)
		name := strings.TrimPrefix(p.Name, "::")
		name = strings.TrimPrefix(name, ":")

		b.WriteString("\t{")
		b.WriteString("Name: " + goStr(name))
		if desc != "" {
			b.WriteString(", Description: " + goStr(desc))
		}
		b.WriteString("},\n")
	}
	b.WriteString("}\n\n")

	// Pseudo-elements.
	b.WriteString(
		"// PseudoElements contains definitions for CSS pseudo-elements.\nvar PseudoElements = []PseudoElement{\n",
	)
	for _, p := range filteredElements {
		desc := parseDescription(p.Description)
		name := strings.TrimPrefix(p.Name, "::")
		name = strings.TrimPrefix(name, ":")

		b.WriteString("\t{")
		b.WriteString("Name: " + goStr(name))
		if desc != "" {
			b.WriteString(", Description: " + goStr(desc))
		}
		b.WriteString("},\n")
	}
	b.WriteString("}\n\n")

	// Maps.
	b.WriteString("var pseudoClassMap = buildPseudoClassMap()\n\n")
	b.WriteString("func buildPseudoClassMap() map[string]PseudoClass {\n")
	b.WriteString("\tm := make(map[string]PseudoClass, len(PseudoClasses))\n")
	b.WriteString("\tfor _, p := range PseudoClasses {\n")
	b.WriteString("\t\tm[p.Name] = p\n")
	b.WriteString("\t}\n")
	b.WriteString("\treturn m\n")
	b.WriteString("}\n\n")

	b.WriteString("var pseudoElementMap = buildPseudoElementMap()\n\n")
	b.WriteString("func buildPseudoElementMap() map[string]PseudoElement {\n")
	b.WriteString("\tm := make(map[string]PseudoElement, len(PseudoElements))\n")
	b.WriteString("\tfor _, p := range PseudoElements {\n")
	b.WriteString("\t\tm[p.Name] = p\n")
	b.WriteString("\t}\n")
	b.WriteString("\treturn m\n")
	b.WriteString("}\n")

	writeFile(filepath.Join(outDir, "pseudo_gen.go"), b.String())
	fmt.Printf("  pseudo_gen.go: %d pseudo-classes, %d pseudo-elements\n",
		len(filteredClasses), len(filteredElements))
}

func writeFile(path, content string) {
	//nolint:gosec // generated source files need 0o644
	if err := os.WriteFile(path, []byte(content), 0o644); err != nil {
		log.Fatalf("writing %s: %v", path, err)
	}
}
