// Command generate-data reads browsers.css-data.json from
// microsoft/vscode-custom-data and produces Go source files for
// the internal/css/data package.
package main

import (
	"cmp"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"slices"
	"strings"
)

const header = "// Code generated by cmd/generate-data; DO NOT EDIT.\n\npackage data\n"

// JSON structures matching browsers.css-data.json.
type cssData struct {
	Properties     []cssProperty    `json:"properties"`
	AtDirectives   []cssAtDirective `json:"atDirectives"`
	PseudoClasses  []cssPseudoClass `json:"pseudoClasses"`
	PseudoElements []cssPseudoElem  `json:"pseudoElements"`
}

type cssProperty struct {
	Name        string          `json:"name"`
	Description json.RawMessage `json:"description"`
	References  []cssReference  `json:"references"`
	Values      []cssValue      `json:"values"`
	Status      string          `json:"status"`
}

type cssAtDirective struct {
	Name        string          `json:"name"`
	Description json.RawMessage `json:"description"`
	References  []cssReference  `json:"references"`
	Status      string          `json:"status"`
}

type cssPseudoClass struct {
	Name        string          `json:"name"`
	Description json.RawMessage `json:"description"`
	References  []cssReference  `json:"references"`
	Status      string          `json:"status"`
}

type cssPseudoElem struct {
	Name        string          `json:"name"`
	Description json.RawMessage `json:"description"`
	References  []cssReference  `json:"references"`
	Status      string          `json:"status"`
}

type cssReference struct {
	Name string `json:"name"`
	URL  string `json:"url"`
}

type cssValue struct {
	Name string `json:"name"`
}

// descriptionObj handles the case where description is
// {kind, value} instead of a plain string.
type descriptionObj struct {
	Kind  string `json:"kind"`
	Value string `json:"value"`
}

func parseDescription(raw json.RawMessage) string {
	if len(raw) == 0 {
		return ""
	}
	// Try string first.
	var s string
	if err := json.Unmarshal(raw, &s); err == nil {
		return s
	}
	// Try object.
	var obj descriptionObj
	if err := json.Unmarshal(raw, &obj); err == nil {
		return obj.Value
	}
	return ""
}

func mdnURL(refs []cssReference) string {
	for _, r := range refs {
		if strings.Contains(r.URL, "developer.mozilla.org") {
			return r.URL
		}
	}
	return ""
}

func isDroppedStatus(status string) bool {
	return status == "nonstandard"
}

func isVendorPrefixed(name string) bool {
	// Strip leading @, :, or :: then check for -.
	s := strings.TrimLeft(name, "@:")
	return strings.HasPrefix(s, "-")
}

func cssValuesFrom(names []string) []cssValue {
	vals := make([]cssValue, len(names))
	for i, n := range names {
		vals[i] = cssValue{Name: n}
	}
	return vals
}

func goStr(s string) string {
	return fmt.Sprintf("%q", s)
}

func main() {
	// Locate project root relative to this source file.
	_, thisFile, _, _ := runtime.Caller(0)
	root := filepath.Join(filepath.Dir(thisFile), "..", "..")

	dataFile := filepath.Join(root, "third_party", "vscode-custom-data",
		"web-data", "data", "browsers.css-data.json")
	outDir := filepath.Join(root, "internal", "css", "data")

	//nolint:gosec // generator tool, path not user-controlled
	raw, err := os.ReadFile(dataFile)
	if err != nil {
		log.Fatalf("reading data file: %v", err)
	}

	var data cssData
	if err := json.Unmarshal(raw, &data); err != nil {
		log.Fatalf("parsing JSON: %v", err)
	}

	generateProperties(outDir, data.Properties)
	generateAtRules(outDir, data.AtDirectives)
	generatePseudo(outDir, data.PseudoClasses, data.PseudoElements)

	fmt.Printf("Generated files in %s\n", outDir)
}

// Properties needing extra values not in the source data.
var extraValues = map[string][]string{
	"outline":        {"none"},
	"pointer-events": {"auto"},
	"white-space":    {"normal", "nowrap", "pre", "pre-wrap", "pre-line", "break-spaces"},
}

// Properties that accept arbitrary identifiers â€” clear their
// generated values so the unknown-value diagnostic is skipped.
var clearValues = map[string]bool{
	"animation":      true,
	"animation-name": true,
	"font-family":    true,
	"grid-area":      true,
}

func generateProperties(outDir string, props []cssProperty) {
	// Filter out vendor-prefixed and obsolete/nonstandard.
	var filtered []cssProperty
	for _, p := range props {
		if !isVendorPrefixed(p.Name) && !isDroppedStatus(p.Status) {
			filtered = append(filtered, p)
		}
	}
	slices.SortFunc(filtered, func(a, b cssProperty) int {
		return cmp.Compare(a.Name, b.Name)
	})

	// Post-process: add missing values and clear values for
	// properties that accept arbitrary identifiers.
	for i := range filtered {
		name := filtered[i].Name
		if extra, ok := extraValues[name]; ok {
			filtered[i].Values = append(filtered[i].Values, cssValuesFrom(extra)...)
		}
		if clearValues[name] {
			filtered[i].Values = nil
		}
	}

	var b strings.Builder
	b.WriteString(header)
	b.WriteString("\n//nolint:dupword\nvar Properties = []Property{\n")

	for _, p := range filtered {
		desc := parseDescription(p.Description)
		mdn := mdnURL(p.References)

		b.WriteString("\t{\n")
		b.WriteString("\t\tName:        " + goStr(p.Name) + ",\n")
		if desc != "" {
			b.WriteString("\t\tDescription: " + goStr(desc) + ",\n")
		}
		if mdn != "" {
			b.WriteString("\t\tMDN:         " + goStr(mdn) + ",\n")
		}
		if p.Status != "" {
			b.WriteString(
				"\t\tStatusInfo:  StatusInfo{Status: " + goStr(p.Status) + "},\n",
			)
		}

		// Collect value keywords (skip vendor-prefixed).
		var vals []string
		for _, v := range p.Values {
			if !strings.HasPrefix(v.Name, "-") {
				vals = append(vals, v.Name)
			}
		}
		if len(vals) > 0 {
			b.WriteString("\t\tValues: []string{")
			if len(vals) <= 4 {
				for i, v := range vals {
					if i > 0 {
						b.WriteString(", ")
					}
					b.WriteString(goStr(v))
				}
				b.WriteString("},\n")
			} else {
				b.WriteString("\n")
				for _, v := range vals {
					b.WriteString("\t\t\t" + goStr(v) + ",\n")
				}
				b.WriteString("\t\t},\n")
			}
		}

		b.WriteString("\t},\n")
	}

	b.WriteString("}\n\n")
	b.WriteString("var propertyMap = buildPropertyMap()\n\n")
	b.WriteString("func buildPropertyMap() map[string]Property {\n")
	b.WriteString("\tm := make(map[string]Property, len(Properties))\n")
	b.WriteString("\tfor _, p := range Properties {\n")
	b.WriteString("\t\tm[p.Name] = p\n")
	b.WriteString("\t}\n")
	b.WriteString("\treturn m\n")
	b.WriteString("}\n")

	writeFile(filepath.Join(outDir, "properties_gen.go"), b.String())
	fmt.Printf("  properties_gen.go: %d properties\n", len(filtered))
}

func generateAtRules(outDir string, directives []cssAtDirective) {
	var filtered []cssAtDirective
	for _, a := range directives {
		if !isVendorPrefixed(a.Name) && !isDroppedStatus(a.Status) {
			filtered = append(filtered, a)
		}
	}
	slices.SortFunc(filtered, func(a, b cssAtDirective) int {
		return cmp.Compare(a.Name, b.Name)
	})

	var b strings.Builder
	b.WriteString(header)
	b.WriteString("\nvar AtRules = []AtRuleDef{\n")

	for _, a := range filtered {
		desc := parseDescription(a.Description)
		// Strip leading @ for the name.
		name := strings.TrimPrefix(a.Name, "@")

		b.WriteString("\t{")
		b.WriteString("Name: " + goStr(name))
		if desc != "" {
			b.WriteString(", Description: " + goStr(desc))
		}
		if a.Status != "" {
			b.WriteString(", StatusInfo: StatusInfo{Status: " + goStr(a.Status) + "}")
		}
		b.WriteString("},\n")
	}

	b.WriteString("}\n\n")
	b.WriteString("var atRuleMap = buildAtRuleMap()\n\n")
	b.WriteString("func buildAtRuleMap() map[string]AtRuleDef {\n")
	b.WriteString("\tm := make(map[string]AtRuleDef, len(AtRules))\n")
	b.WriteString("\tfor _, a := range AtRules {\n")
	b.WriteString("\t\tm[a.Name] = a\n")
	b.WriteString("\t}\n")
	b.WriteString("\treturn m\n")
	b.WriteString("}\n")

	writeFile(filepath.Join(outDir, "at_rules_gen.go"), b.String())
	fmt.Printf("  at_rules_gen.go: %d at-rules\n", len(filtered))
}

func generatePseudo(outDir string, classes []cssPseudoClass, elements []cssPseudoElem) {
	// Filter and sort pseudo-classes.
	var filteredClasses []cssPseudoClass
	for _, p := range classes {
		if !isVendorPrefixed(p.Name) && !isDroppedStatus(p.Status) {
			filteredClasses = append(filteredClasses, p)
		}
	}
	slices.SortFunc(filteredClasses, func(a, b cssPseudoClass) int {
		return cmp.Compare(a.Name, b.Name)
	})

	// Filter and sort pseudo-elements.
	var filteredElements []cssPseudoElem
	for _, p := range elements {
		if !isVendorPrefixed(p.Name) && !isDroppedStatus(p.Status) {
			filteredElements = append(filteredElements, p)
		}
	}
	slices.SortFunc(filteredElements, func(a, b cssPseudoElem) int {
		return cmp.Compare(a.Name, b.Name)
	})

	var b strings.Builder
	b.WriteString(header)

	// Pseudo-classes.
	b.WriteString(
		"\n// PseudoClasses contains definitions for CSS pseudo-classes.\nvar PseudoClasses = []PseudoClass{\n",
	)
	for _, p := range filteredClasses {
		desc := parseDescription(p.Description)
		name := strings.TrimPrefix(p.Name, "::")
		name = strings.TrimPrefix(name, ":")

		b.WriteString("\t{")
		b.WriteString("Name: " + goStr(name))
		if desc != "" {
			b.WriteString(", Description: " + goStr(desc))
		}
		if p.Status != "" {
			b.WriteString(", StatusInfo: StatusInfo{Status: " + goStr(p.Status) + "}")
		}
		b.WriteString("},\n")
	}
	b.WriteString("}\n\n")

	// Pseudo-elements.
	b.WriteString(
		"// PseudoElements contains definitions for CSS pseudo-elements.\nvar PseudoElements = []PseudoElement{\n",
	)
	for _, p := range filteredElements {
		desc := parseDescription(p.Description)
		name := strings.TrimPrefix(p.Name, "::")
		name = strings.TrimPrefix(name, ":")

		b.WriteString("\t{")
		b.WriteString("Name: " + goStr(name))
		if desc != "" {
			b.WriteString(", Description: " + goStr(desc))
		}
		if p.Status != "" {
			b.WriteString(", StatusInfo: StatusInfo{Status: " + goStr(p.Status) + "}")
		}
		b.WriteString("},\n")
	}
	b.WriteString("}\n\n")

	// Maps.
	b.WriteString("var pseudoClassMap = buildPseudoClassMap()\n\n")
	b.WriteString("func buildPseudoClassMap() map[string]PseudoClass {\n")
	b.WriteString("\tm := make(map[string]PseudoClass, len(PseudoClasses))\n")
	b.WriteString("\tfor _, p := range PseudoClasses {\n")
	b.WriteString("\t\tm[p.Name] = p\n")
	b.WriteString("\t}\n")
	b.WriteString("\treturn m\n")
	b.WriteString("}\n\n")

	b.WriteString("var pseudoElementMap = buildPseudoElementMap()\n\n")
	b.WriteString("func buildPseudoElementMap() map[string]PseudoElement {\n")
	b.WriteString("\tm := make(map[string]PseudoElement, len(PseudoElements))\n")
	b.WriteString("\tfor _, p := range PseudoElements {\n")
	b.WriteString("\t\tm[p.Name] = p\n")
	b.WriteString("\t}\n")
	b.WriteString("\treturn m\n")
	b.WriteString("}\n")

	writeFile(filepath.Join(outDir, "pseudo_gen.go"), b.String())
	fmt.Printf("  pseudo_gen.go: %d pseudo-classes, %d pseudo-elements\n",
		len(filteredClasses), len(filteredElements))
}

func writeFile(path, content string) {
	//nolint:gosec // generated source files need 0o644
	if err := os.WriteFile(path, []byte(content), 0o644); err != nil {
		log.Fatalf("writing %s: %v", path, err)
	}
}
